// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "tempgrpcd.proto" (package "tempgrpcd", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message tempgrpcd.TempgrpcdRequest
 */
export interface TempgrpcdRequest {
    /**
     * @generated from protobuf field: uint32 version = 1
     */
    version: number;
    /**
     * @generated from protobuf field: uint64 start_time = 2
     */
    startTime: bigint;
    /**
     * @generated from protobuf field: uint64 end_time = 3
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: optional uint64 samples = 4
     */
    samples?: bigint;
}
/**
 * @generated from protobuf message tempgrpcd.TempgrpcdResponse
 */
export interface TempgrpcdResponse {
    /**
     * @generated from protobuf field: uint32 version = 1
     */
    version: number;
    /**
     * @generated from protobuf field: map<string, tempgrpcd.AmbientCondition> ambient_conditions = 2
     */
    ambientConditions: {
        [key: string]: AmbientCondition;
    };
}
/**
 * @generated from protobuf message tempgrpcd.AmbientCondition
 */
export interface AmbientCondition {
    /**
     * @generated from protobuf field: float temperature = 1
     */
    temperature: number;
    /**
     * @generated from protobuf field: float humidity = 2
     */
    humidity: number;
    /**
     * @generated from protobuf field: float illumination = 3
     */
    illumination: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class TempgrpcdRequest$Type extends MessageType<TempgrpcdRequest> {
    constructor() {
        super("tempgrpcd.TempgrpcdRequest", [
            { no: 1, name: "version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "end_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "samples", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TempgrpcdRequest>): TempgrpcdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0;
        message.startTime = 0n;
        message.endTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<TempgrpcdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TempgrpcdRequest): TempgrpcdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* uint64 start_time */ 2:
                    message.startTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_time */ 3:
                    message.endTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 samples */ 4:
                    message.samples = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TempgrpcdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* uint64 start_time = 2; */
        if (message.startTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.startTime);
        /* uint64 end_time = 3; */
        if (message.endTime !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.endTime);
        /* optional uint64 samples = 4; */
        if (message.samples !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.samples);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tempgrpcd.TempgrpcdRequest
 */
export const TempgrpcdRequest = new TempgrpcdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TempgrpcdResponse$Type extends MessageType<TempgrpcdResponse> {
    constructor() {
        super("tempgrpcd.TempgrpcdResponse", [
            { no: 1, name: "version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "ambient_conditions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => AmbientCondition } }
        ]);
    }
    create(value?: PartialMessage<TempgrpcdResponse>): TempgrpcdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0;
        message.ambientConditions = {};
        if (value !== undefined)
            reflectionMergePartial<TempgrpcdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TempgrpcdResponse): TempgrpcdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* map<string, tempgrpcd.AmbientCondition> ambient_conditions */ 2:
                    this.binaryReadMap2(message.ambientConditions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: TempgrpcdResponse["ambientConditions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TempgrpcdResponse["ambientConditions"] | undefined, val: TempgrpcdResponse["ambientConditions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = AmbientCondition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for tempgrpcd.TempgrpcdResponse.ambient_conditions");
            }
        }
        map[key ?? ""] = val ?? AmbientCondition.create();
    }
    internalBinaryWrite(message: TempgrpcdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* map<string, tempgrpcd.AmbientCondition> ambient_conditions = 2; */
        for (let k of globalThis.Object.keys(message.ambientConditions)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AmbientCondition.internalBinaryWrite(message.ambientConditions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tempgrpcd.TempgrpcdResponse
 */
export const TempgrpcdResponse = new TempgrpcdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AmbientCondition$Type extends MessageType<AmbientCondition> {
    constructor() {
        super("tempgrpcd.AmbientCondition", [
            { no: 1, name: "temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "humidity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "illumination", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AmbientCondition>): AmbientCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.temperature = 0;
        message.humidity = 0;
        message.illumination = 0;
        if (value !== undefined)
            reflectionMergePartial<AmbientCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AmbientCondition): AmbientCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float temperature */ 1:
                    message.temperature = reader.float();
                    break;
                case /* float humidity */ 2:
                    message.humidity = reader.float();
                    break;
                case /* float illumination */ 3:
                    message.illumination = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AmbientCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float temperature = 1; */
        if (message.temperature !== 0)
            writer.tag(1, WireType.Bit32).float(message.temperature);
        /* float humidity = 2; */
        if (message.humidity !== 0)
            writer.tag(2, WireType.Bit32).float(message.humidity);
        /* float illumination = 3; */
        if (message.illumination !== 0)
            writer.tag(3, WireType.Bit32).float(message.illumination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tempgrpcd.AmbientCondition
 */
export const AmbientCondition = new AmbientCondition$Type();
/**
 * @generated ServiceType for protobuf service tempgrpcd.Tempgrpcd
 */
export const Tempgrpcd = new ServiceType("tempgrpcd.Tempgrpcd", [
    { name: "GetAmbientConditions", options: {}, I: TempgrpcdRequest, O: TempgrpcdResponse }
]);
